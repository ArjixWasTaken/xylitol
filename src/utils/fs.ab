import { split, starts_with, char_at } from "std/text"

/// Get directory entries as array of "name\ttype" strings
/// type: "d" for directory, "f" for file
pub fun get_directory_entries(path: Text): [Text] {
    let raw = trust $ ls -lA "{path}" 2>/dev/null | tail -n +2 $
    let types = trust $ ls -lA "{path}" | tail -n +2 | sed -E 's/^(.).*/\1/' $
    let names = trust $ ls -1A "{path}" $

    let types = split(types, "\n")
    let raw = split(raw, "\n")
    let names = split(names, "\n")
    let entries = [Text]

    for i in 0..len(raw) {
        let file_type = "f"
        let target = ""
        if {
            types[i]== "-" {
                file_type = "f"
            }
            types[i] == "l" {
                target = trust $ echo {raw[i]} | sed 's/.*-> //' $
                file_type = "l"
            }
        }

        if file_type == "l" {
            entries += ["{names[i]}\t{types[i]}\t{target}"]
        } else {
            entries += ["{names[i]}\t{types[i]}"]
        }
    }

    return entries
}

/// Parse entry string into [name, type, target]
pub fun parse_entry(entry: Text): [Text] {
    return split(entry, "\t")
}

/// Get current working directory
pub fun get_cwd(): Text {
    return trust $ pwd $
}

/// Normalize a path (resolve .. and .)
pub fun normalize_path(path: Text): Text {
    let normalized = trust $ cd "{path}" 2>/dev/null && pwd $
    if normalized == "" {
        return path
    }
    return normalized
}

/// Check if path is a directory
pub fun is_directory(path: Text): Bool {
    let result = trust $ [ -d "{path}" ] && echo "1" || echo "0" $
    return result == "1"
}

/// Join two path components
pub fun path_join(base: Text, child: Text): Text {
    if base == "/" {
        return "/" + child
    }
    return base + "/" + child
}

/// Get parent directory
pub fun get_parent_dir(path: Text): Text {
    let parent = trust $ dirname "{path}" $
    return parent
}
